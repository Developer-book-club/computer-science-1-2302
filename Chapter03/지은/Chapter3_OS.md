#  OS 운영체제 

# 3.1 운영체제와 컴퓨터
## 3.1.1 운영체제의 역할과 구조 

### 운영체제
- 유저가 컴퓨터를 쉽게 다루게 해주는 *인터페이스*
- 한정된 메모리, 시스템 자원을 효율적으로 분배


### 펌웨어
- 운영체제와 역할은 유사, 소프트웨어를 추가로 설치할 수 없음

### 운영체제의 역할
1. CPU 스케줄링과 프로세스 관리
- CPU에 대한 소유권을 어떤 프로세스에 할당할지, 프로세스의 생성, 삭제,
 자원 할당 및 반환 관리
2. 메모리 관리
- 한정된 메모리의 프로세스 위치 및 할당량 관리
3. 디스크 관리
- 디스크 파일을 어떤 방식으로 보관할지 관리
4. I/O 디바이스 관리
- 마우스, 키보드 등 입출력 장치들 간의 데이터를 주고 받는 것을 관리


### 운영체제의 구조 

| 유저프로그램 |
| --- |
| GUI (CUI - 리눅스 서버) |
| 시스템콜 (인터페이스) |
| 커널 |
| 드라이버 |
| 하드웨어 |


GUI
- CLI와 같은 단순 명령어 창이 아닌 전자장치와 사용자가 상호작용하는 인터페이스의 형태 
- ex. sourceTree, gitkraken 등 

드라이버
- 장치 드라이버/제어기(문화어: 장치구동기, 장치구동프로그람) 또는 디바이스 드라이버(영어: device driver)는 특정 하드웨어나 장치를 제어하기 위한 소프트웨어
컴퓨터를 구성하는 다양한 입출력 장치마다 각각 장치드라이버가 프로그램 되어 커널에 통합되어 실행됨.
높은 수준의 컴퓨터 프로그램들이 컴퓨터 하드웨어 장치와 상호 작용하기 위해 만들어진 하나의 컴퓨터 프로그램이다. https://ko.wikipedia.org/wiki/%EC%9E%A5%EC%B9%98_%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B2%84


시스템 콜
- 운영체제가 커널에 접근하기 위한 인터페이스
- 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 경우 사용
- 컴퓨터 자원에 대한 직접 접근을 차단. 다른프로그램으로부터 프로그램을 보호 


Modebit(플래그 변수)
- 유저 프로그램이 운영체제의 서비스를 받기 위한 과정에서 커널 함수 호출 시 시스템 콜 사용 (공격 위험성 ⬇️)
- 시스템 콜에서 요청을 처리할 때 modebit을 참고하여 유저 모드 / 커널 모드를 구분

커널(운영체제의 핵심)
- 시스템 콜 인터페이스 제공
- 보안, 메모리, 프로세스, 파일 시스템, I/O 디바이스, I/O 관리 등 운영체제의 중추 역할 수행


## 3.1.2 컴퓨터의 요소 
- CPU, DMA 컨트롤러, 메모리, 타이머, 디바이스 컨트롤러 등

### CPU (Central Processing Unit)
- 산술논리연산장치, 제어장치, 레지스터로 구성 
- 인터럽트에 의해 메모리에 존재하는 명령어를 해석하여 실행

제어장치(CU, Control Unit)
- 프로세스 조작을 지시하는 cpu의 부품
- 입출력 간 통신 제어, 명령어 읽기/해석
- 데이터 처리를 위한 순서 결정

레지스터
- CPU안의 매우 빠른 임시기억장치
- CPU와 직접연결이 되어 있어 연산속도가 메모리에 비해 수십~수백배 빠름
- CPU는 자체적으로 데이터를 저장할 수 없어 레지스터를 거쳐 데이터를 전달

산술논리연산장치(ALU, Arithmetic Logic Unit)
- 덧셈, 뺄셈과 같은 두 숫자의 산술 연산, 논리합, 논리곱 같은 논리연산을 계산하는 디지털 회로 

DMA 컨트롤러  
- I/ O 디바이스가 메모리에 직접  접근할 수 있도록 하는 하드웨어 장치
-  CPU 부하를 막아준다
- CPU의 일을 부담하는 보조 일꾼
- 하나의 task에 대해 CPU와 DMA 컨트롤러가 동시에 작업 하는 것을 방지


메모리(Memory)
- 전자회로에서 데이터나 상태, 명령어 등을 기록하는 장치
- 보통 RAM을 일컬음
- CPU가 계산을 담당할 때 메모리는 기억 담당

타이머 (Timer)
- 특정 프로그램에 시간 제한 시 사용
- 시간이 많이 걸리는 프로그램이 작동할 때 제한을 걸기 위해 존재


디바이스 컨트롤러  
- 컴퓨터와 연결되어 있는 IO 디바이스들의 작은 CPU
- 로컬 버퍼: 디바이스 컨트롤러 옆에 위치. 각 디바이스에서 데이터를 임시로 저장하기 위한 작은 메모리


---
# 3.2 메모리

## 3.2.1 메모리 계층
- 레지스터, 캐시, 메모리, 저장장치로 구성  

### 주기억장치
1. 레지스터
- CPU안에 있는 작은 메모리
2. 캐시
- L1, L2 캐시 지칭. 휘발성, 속도빠름, 기억 용량이 적다.
3. 주기억장치
- RAM. 휘발성, 속도 보통, 기억용량 보통
4. 보조기억장치
- HDD, SSD. 비휘발성, 속도 낮음, 기억용량 많음

캐시
- 데이터를 미리 복사해놓는 임시 저장소
- 속도 차이에 따른 병목현상을 줄이기 위한 메모리

지역성의 원리 
- 캐시 계층을 두지 않고 직접 설정 시 사용됨 

시간적 지역성  
- 데이터가 한번 접근되었을 경우, 가까운 미래에 또 한번 데이터에 접근할 가능성이 높은 것  
공간적 지역성  
- 특정 데이터와 가까운 주소가 순서대로 접근되었을 경우

캐시히트와 캐시미스
캐시히트
- 캐시에서 원하는 데이터를 찾은 경우 
캐시미스
- 캐시에 없을 때 주메모리로 가서 데이터를 찾아올 때 
캐시매핑
- 캐시가 히트되기 위해 매핑하는 방법

웹 브라우저의 캐시
사용자의 커스텀한 정보나 인증 모듈 관련 사항들을 웹 브라우저에 저장해서 추후 서버에 요청할 때 \n 자신을 나타내는 신원이나 중복 요청 방지를 위해 사용

## 3.2.2 메모리 관리

가상 메모리
- 컴퓨터가 실제 이용 가능한 메모리 자원을 추상화
- 메모리 관리 장치에 의해 가상주소 -> 실제주소로 변환
- 사용자는 실제 주소를 고려하지 않고 프로그램 구축 가능

TLB
- 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시
- 페이지 테이블에 있는 리스트 보관 / CPU가 페이지 테이블까지 가지 않아 속도 향상을 시키는 캐시 계층

페이지 폴트
- 프로세스 주소 공간에는 존재하지만 컴퓨터의 RAM에 없는 데이터에 접근했을 경우 발생

스와핑
- 페이지 폴트의 경우 메모리에서 사용하지 않는 영역을 하드디스크에 옮기고 하드디스크의 일부분을 메모리처럼 불러와 쓰는 것
- 페이지 폴트가 일어나지 않은 상황처럼 보이도록 함

스레싱
- 메모리의 페이지 폴트율이 높은 것
- 메모리에 많은 프로세스가 동시에 올라가 스와핑이 많이 일어나 발생
    - 해결방안
    - 메모리를 늘리거나, HDD->SDD로 변환하여 스레싱 문제 해결
    - 작업세트, PFF 

메모리 할당
- 시작 메모리 위치, 메모리 할당 크기를 기반으로 할당

연속 할당  
- 메모리에 순차적으로(연속적으로) 공간을 할당

고정 분할 방식
- 메모리가 미리 나누어 관리 

가변 분할 방식
- 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용
- 종류: 최초적합 / 최적적합 / 최악접합  

- 불연속 할당 

메모리를 동일한 크기의 페이지로 나누고 프로그램마다 페이지 테이블을 두어 이를 통해 메모리에 프로그램을 할당

### 페이지 교체 알고리즘
- 스와핑이 많이 일어나지 않도록 설계되어야 함 -> 페이지 교체 알고리즘을 기반으로 스와핑

오프라인 알고리즘  
- 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘

FIFO(First in First Out)
- 가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법

LRU(Least Recentle Used)
- 최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 것

NUR(Not Used Recently)
- 최근에 사용하지 않은 페이지를 교체하는 것

LFU(Least Frequently Used)
- 가장 참조 횟수가 적은 페이지 교체
- 많이 사용되지 않은 것을 교체하는 것

---

# 3.3 프로세스와 스레드
프로세스    
- 컴퓨터에서 실행되고 있는 프로그램. CPU 스케줄링의 대상이 되는 작업
스레드    
- 프로세스 내 작업의 흐름을 지칭

## 3.3.1 프로세스와 컴파일 과정
`프로세스`는 `프로그램`으로부터 인스턴스화된 것
`프로그램`은 컴퓨터가 이해할 수 있는 기계어로 번역되어 실행할 수 있는 `컴파일`을 수행해야 함

전처리
- 소스코드의 주석 제거
- ` #include` 등 헤더 파일을 병합하여 매크로 치환

컴파일러
- 오류 처리, 코드 최적화 작업을 하며 어셈블리어로 변환  

어셈블러
- 목적 코드(object code)로 변환. 
- 리눅스 기준 확장자 `.o`

링커
- 프로그램 내에 있는 라이브러리 함수 또는 다른 파일들과 결합(링크)하여 실행 파일을 만드는 과정

라이브러리 종류
정적 라이브러리
- 프로그램 빌드 시 필요로 하는 모든 코드를 라이브러리에서 찾아 실행 파일에 복사하는 방식
동적 라이브러리
- 라이브러리 내용의 주소만 가지고 있다가 프로그램 실행 시 해당 주소로 가서 필요한 내용을 가져오는 방식

## 3.3.2 프로세스의 상태

생성 상태 (Created State)
- 프로세스가 생성되는 상태
- 작업을 커널에 등록하고, PCB가 할당

대기 상태 (Ready)
- 프로세스가 CPU 스케줄러로부터 CPU 소유권이 넘어오기를 기다리는 상태

대기 중단 상태(Ready suspended)  
- 메모리 부족으로 일시 중단된 상태

실행 상태(Running)  
- 프로세스에 CPU 소유권과 메모리를 할당 받고 명령어가 실행되고 있는 상태

중단 상태(Blocked) 
- 어떤 이벤트가 발생한 이후 기다리며 프로세스가 차단된 상태

일시 중단 상태(Blocked suspended)
- 대기 중단과 유사하며 중단된 상태에서 메모리 부족으로 프로세스가 일시 중단된 상태

종료 상태(Terminated)
- 프로세스 실행이 완료 후 메모리와 CPU 소유권을 모두 놓고 가는 상태

## 3.3.3 프로세스의 메모리 구조

### 스택과 힙
- 스택
    - 지역변수, 매개변수, 함수가 저장되고 컴파일 시 에 크기가 결정. 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 공간.
- 힙
    - 동적 할당할 때 런타임 시 크기 결정. 프로그래머가 필요할 때마다 사용하는 메모리 영역  

데이터 영역
전역 변수나 static 변수 등 프로그램이 사용하는 데이터를 저장하는 공간  
- BSS 영역: 초기화되지 않은 변수가 0으로 초기화되어 저장  
- Data 영역: 0이 아닌 다른 값으로 할당된 변수들의 저장  

코드 영역
- 사용자가 작성한  프로그램 함수들의 코드가 CPU가 수행할 수 있는 기계어 명령 형태로 변환되어 저장되는 공간

## 3.3.4 PCB

### PCB(Process Control Block)
- 운영체제에서 프로세스에 대한 메타데이터를 저장한 '데이터'
- 프로그램이 실행되면 프로세스가 생성되고 프로세스 주소 값들에 스택, 힙, 등의 구조를 기반으로 메모리가 할당
- 프로세스의 메타데이터들이 PCB 에 저장되어 관리된다.

### PCB의 구조
`프로세스 스케줄링 상태``프로세스 ID` `프로세스 권한``프로그램 카운터``CPU 레지스터``CPU 스케줄링 정보``계정정보``I/O 상태 정보`  

### 컨텍스트 스위칭
- PCB를 교환하는 과정을 말한다.    
- 한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생
- 어떠한 시점에서 실행되고 있는 프로세스는 단 한 개. 다른 프로세스와의 컨텍스트 스위칭이 아주 빠른 속도로 실행됨(싱글코어를 기준)

## 3.3.5 멀티프로세싱
멀티 프로세싱은 여러 개의 프로세스(멀티 프로세스) 를 통해 동시에 두 가지 이상의 일을 수행할 수 있는 것

### 웹 브라우저의 멀티프로세스 구조 
- 브라우저 프로세스: 네트워크 요청이나 파일 접근 같은 `권한 담당`
- 렌더러 프레세스: 웹사이트가 `보이는` 부분의 모든 것 제어 
- 플러그인 프로세스: 웹사이트에서 사용하는 플러그인 제어
- GPU 프로세스: 화면을 그리는 부분 제어  

### IPC(Inter Process Communication)
- IPC는 프로세스끼리 데이터를 주고받고 공유 데이터를 관리하는 메커니즘
- 멀티프로세스는 IPC가 가능
- 메모리가 완전히 공유되는 스레드보다는 속도가 떨어짐

### 공유 메모리
- 여러 프로세스에 동일한 메모리 블록에 대한 접근 권한 부여
- 프로세스가 서로 통신할 수 있도록 해주는 역할
- 하드웨어 관점에서는 CPU가 접근할 수 있는 큰 랜덤 접근 메모리인 RAM을 가리키기도 함

## 3.3.6 스레드와 멀티스레딩  

### 스레드
- 스레드는 프로세스의 실행 가능한 가장 작은 단위. 여러 스레드를 가질 수 있음
- 코드, 데이터, 스택, 합을 각각 생성하는 프로세스와 달리 스레드는 코드, 데이터, 힙은 스레드끼리 서로 공유
  
### 멀티스레딩 
- 멀티스레딩은 프로세스 내 작업을 여러 개의 스레드, 멀티스레딩로 처리하는 기법  
- 스레드끼리 자원을 서로 공유하기 때문에 효율성이 높음
- 서로 독립적인 작업들을 작은 단위로 나누고 동시에 실행되는 것처럼 보여주는 동시성의 큰 장점을 가짐
- 한 스레드에 문제가 생기면 다른 스레드에도 영향을 끼쳐 스레드 기반의 프로세스에 영향을 줄 수 있다는 단점을 가짐  

## 3.3.7 공유 자원과 임계영역
### 공유자원
- 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 자원이나 변수
- 모니터 / 프린터 / 메모리 / 파일 / 데이터 등 

### 임계영역
- 둘 이상의 프로세스, 스레드가 공유자원에 접근할 때 순서 등의 이유로 결과가 달라지는 코드 영역
- 해결 방법으로 상호 배제 / 한정 대기 / 융통성 이 있다.

## 3.3.8 교착상태
교착상태(deadlock)는 두 개 이상의 프로세스들이 서로가 가진 지원을 기다리며 중단된 상태를 말한다.  


---

# 3.4 CPU 스케줄링 알고리즘
CPU 스케줄러는 CPU 스케줄링 알고리즘에 따라 프로세스에서 해야 하는 일을 스레드 단위로 CPU에 할당

## 비선점형 방식 (`FCFS` / `SJF` / `우선순위`)
비선점형 방식은 프로세스가 스스로 CPU 소유권을 포기하는 방식이며, 강제로 프로세스를 중지하지 않음  
컨텍스트 스위칭으로 인한 부하가 적음

### FCFS (First Come, First Served)
가장 먼저 온 것을 가장 먼저 처리하는 알고리즘  
단점: 길게 수행되는 프로세스 떄문에 '준비 큐에서 오래 기다리는 현상(convoy effect)'이 발생

### SJF (Shortest Job First) 
SJF는 실행 시간이 가장 짧은 프로세스를 가장 먼저 실행하는 알고리즘  
특징: 긴 시간을 가진 프로세스가 실행되지 않는 현상(starvation)이 일어나며 평균 대기 시간이 짧음

### 우선순위
오래된 작업일수록 '우선순위를 높이는 방법(aging)'을 통해 SJF 의 긴 시간을 가진 프로세스가 실행되지 않는 현상(starvation)을 보완한 알고리즘

## 선점형 방식 (`라운드로빈` / `SRF' /  `다단계 큐`)
선점형 방식은 현대 운영체제가 쓰는 방식으로 지금 사용하고 있는 프로세스를 알고리즘에 의해 중단시켜 버리고 강제로 다른 프로세스를 CPU 소유권을 할당하는 방식

### 라운드 로빈 (RR, Round Robin)
라운드 로빈은 우선순위 스케줄링의 일종으로 각 프로세스는 동일한 할당 시간을 주고 그 시간 안에 끝나지 않으면 큐(ready queue)의 뒤로 가는 알고리즘  

### SRF
SRF 는 중간에 더 짧은 작업이 들어오면 수행하던 프로세스를 중지하고 해당 프로세스를 수행하는 알고리즘

### 다단계 큐
다단계 큐는 우선순위에 따른 준비 큐를 여러 개 사용하고, 큐마다 라운드 로빈이나 FCFS 등 다른 스케줄링 알고리즘을 적용
- 높은 우선 순위 - 시스템 프로세스(FCFS)
- 중간 우선 순위 - 상호 작용적인 프로세스(SJF)
- 낮은 우선순위 - 배치 프로세스(RR)






