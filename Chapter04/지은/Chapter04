# 4.1 데이터 베이스의 기본

데이터베이스(DB, DataBase)
- 일정한 규칙, 규약을 통해 구조화되어 저장되는 데이터의 모음
- 내부의 데이터들은 특정 DBMS마다 정의된 쿼리언어를 통해 삽입, 삭제, 조회, 수정이 가능
- 실시간 접근, 동시 공유 가능

DBMS
- 데이터 베이스를 제어, 관리하는 통합 시스템

/var/folders/8_/z9yztddj6wbczy__9s_gjwr00000gn/T/TemporaryItems/NSIRD_screencaptureui_nj6dvr/스크린샷 2023-02-25 오후 10.51.05.png

데이터 베이스 위에 DBMS이 있고, 사용자, 응용프로그램과 서로 데이터를 주고 받는다. 

## 4.1.1 엔터티

엔터티(entity)
- 사람, 장소, 물건, 사건, 개념 등 여러개의 속성을 지닌 명사
- 서비스의 요구 사항에 맞춰 속성이 정해지며 무관한 경우 속성에서 제외됨.
Ex. 회원의 경우 엔터티는 이름, 아이디, 주소, 전화번호 

약한 엔터티와 강한 엔터티
- A와 B중 상대적으로 나뉨
- 혼자 존재하지 못하는 종속적인 엔터티의 경우 약한 엔터티, 그게 아니라면 강한 엔터티

## 4.1.2 릴레이션(relation)
- 데이터베이스에서 정보를 구분하여 저장하는 기본 단위.
- 엔터티에 관한 데이터를 릴레이션 하나에 담아서 관리
- 관계형 데이터베이스에서는 '테이블', NoSqL 데이터베이스에서는 '컬렉션'이라고 함

테이블과 컬렉션
- 관계형 데이터베이스(MySQL)와 NoSQL 데이터베이스로 나뉨

데이터베이스 구조 
MySQL: 레코드 - 테이블 - 데이터베이스
MongoDB: 도큐먼트 - 컬렉션 - 데이터 베이스

## 4.1.3 속성(Attribute)
- 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보

## 4.1.4 도메인(domain)
- 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합
Ex. 속성 성별. 속성이 가질 수 있는 값은 {남, 여}

## 4.1.5 필드와 레코드
/var/folders/8_/z9yztddj6wbczy__9s_gjwr00000gn/T/TemporaryItems/NSIRD_screencaptureui_4KBdaz/스크린샷 2023-02-25 오후 11.05.38.png

해당 테이블의 속성은 학번, 소속, 성명, 본적, 전화번호 를 갖고 있으며 필드 이름또한 동일하다.
여기서 쌓이는 행 단위의 데이터를 레코드(=튜플)이라고 함

한글 이름을 속성으로 쓰지는 않기 때문에 title, author, id 등으로 속성을 영어 이름에 매핑, 타입을 정의.

필드 타입
- 필드는 타입을 지며 숫자, 날짜 문자 타입 등이 있다. 
/var/folders/8_/z9yztddj6wbczy__9s_gjwr00000gn/T/TemporaryItems/NSIRD_screencaptureui_77t2FH/스크린샷 2023-02-25 오후 11.11.34.png

## 4.1.6 관계
- 데이터 베이스에는 여러개의 테이블이 있으며, 서로의 관계가 정의되어 있다.
- 관계 정의는 관계 화살표로 나타낸다.
/var/folders/8_/z9yztddj6wbczy__9s_gjwr00000gn/T/TemporaryItems/NSIRD_screencaptureui_EZvqdx/스크린샷 2023-02-25 오후 11.14.07.png

1:1 관계
- 하나의 레코드가 다른 테이블의 레코드 한 개와 연결된 경우
- 두개의 테이블로 나눠 테이블의 구조를 이해하기 쉽다.

1:N 관계
- 하나의 레코드가 서로 다른 여러개의 레코드와 연결된 경우
- 관계형 데이터베이스(RDBMS) 에서 가장 많이 사용
  `RDBMS`: 데이터가 하나 이상의 열과 행의 테이블에 저장되어 서로 다른 데이터 구조가 어떻게 관련되어 있는지 쉽게 파악할 수 있도록 데이터를 구성하는 정보 모음

N:M 관계
- 여러 개의 레코드가 다른 테이블의 여러 개의 레코드와 관계가 있는 경우
- 양방향에서 다수의 레코드를 가질 수 있다.

## 4.1.7 키
테이블 간의 관계를 명확히 하고 테이블 자체의 인덱스를 위해 설정된 장치
기본키, 외래키, 후보키, 대체키가 있음

기본키(PK, Primary key)
- 유일성과 최소성 만족하는 키

자연키
- 중복된 값들을 제외하며 중복되지 않는 것을 뽑다가 나오는 키 
- 언젠가는 변하는 속성

인조키
- 인위적으로 생성한 키
- 자연키와는 대조적으로 변하지 않기 때문에 기본키는 인조키로 설정

외래키(Foreign Key, FK)
- 다른 테이블의 기본키를 그대로 참조하는 값
- 개체와의 관계를 식별하는데 사용
- 중복 가능

후보키(Candidate key)
- 기본키가 될 수 있는 후보 
- 유일성과 최소성을 동시에 만족

대체키(Alternate key)
- 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키

슈퍼키(Super key)
- 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키

# 4.2 ERD와 정규화 과정
ERD(Entity Relationship Diagram)
: 데이터베이스를 구촉할 때 가장 기초적인 뼈대 역할, 릴레이션 간의 관계 정의

## 4.2.1 ERD의 중요성
- 시스템의 요구사항 기반으로 작성되며, ERD 기반으로 데이터 베이스 구축
- 구축 이후 디버깅 또는 비즈니스 프로세스 재설계가 필요한 경우 설계도 역할 담당
- 관계형 구조로 표현할 수 있는 데이터 구성 시 유용하나 비정형 데이터를 충분히 표현할 수 없음
`비정형 데이터`: 비 구조화 데이터, 미리 정의된 데이터가 모델이 없거나 미리 정의된 방식으로 정리되지 않은 정보

## 4.2.3 정규화 과정
릴레이션 간의 잘못된 종속 관계로 인한 데이터베이스 이상 현상이 일어날 수 있음
효율적인 저장 공간 사용을 위해 릴레이션을 여러 개로 분리하는 과정

정규형 원칙
1. 제 1정규형
- 릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자 값(atomic value)만으로 구성되어야 함
- 릴레이션의 속성 값 중 한 개의 기본키에 대해 두 개 이상의 값을 가지는 반복 집합이 있어서는 안되며, 있다면 제거해야 함

2. 제 2정규형
- 릴레이션이 제 1정규형을 만족하며, 부분 함수의 종속성을 제거한 형태
- 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것을 말함 

3. 제 3정규형
- 제 2정규형이고 기본키가 아닌 모든 속성이 이행적 함수 종속을 만족하지 않은 상태
`이행적 함수 종속`: A->B, B->C가 존재하면 논리적으로 A->C가 성립하는데, 이 때 집합 C가 집합 A에 이행적으로 함수 종속이 되었다고 함.

4. 보이스/코드 정규형(BCNF)
- 제 3정규형이고 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태
결정자: 함수 종속 관계에서 특정 종속자를 결정짓는 요소. X->Y일 때 X는 결정자. Y는 종속자

# 4.3 트랜잭션과 무결성

## 4.3.1 트랜잭션
- 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위
- 쿼리로 접근하며 여러 개의 쿼리들을 하나로 묶는 단위
- ACID 특징을 갖고 있음

원자성(Atomicity)
- 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징

커밋과 롤백
커밋(Commit)
- 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어
- 트랜잭션 단위로 수행. 변경된 내용이 모두 영구적으로 저장되는 것

롤백
- 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일

트랜잭션 전파
- 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것 

일관성(Consistency)
- 데이터베이스에 기록된 모든 데이터는 여러 가지 조건, 규칙에 따라 유효함을 가져야 함
- '허용된 방식'으로만 데이터를 변경해야 하는 것

격리성(Isolation)
- 트랜잭션 수행 시 서로 끼어들지 못하는 것
- 복수의 병렬 트랜잭션 수행 시 순차적으로 실행되는 것처럼 작동 및 여러 사용자가 같은 데이터에 접근할 수 있도록 격리 수준으로 나누어 격리성 보장

지속성(Durability)
- 성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것
- 데이터베이스에 시스템 장애가 발생하여도 원래 상태로 복구하는 회복 기능(ex, 체크섬, 저널링 등)이 있어야 함

## 4.3.2 무결성
데이터의 정확성, 일관성, 유효성을 유지하는 것. 무결성이 유지되어야 데이터베이스에 저장된 데이터 값과 그 값에 해당하는 실제 값이 일치하는 것에 대한 신뢰가 생김.

|이 름|설명|
|------|-----|
|개체 무결성|기본키로 선택된 필드는 빈 값을 허용하지 않습니다.|
|참조 무결성|서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지한다.|
|고유 무결성|특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값이어야 한다.|
|NULL 무결성|특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될 수 없다는 제약 조건이다.|

# 4.4 데이터베이스의 종류
## 4.4.1 관계형 데이터베이스(RDBMS)
- 행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스
- SQL언어를 사용하여 조작

## MySQL
- 대부분의 os와 호환. 가장 많이 사용되어지는 데이터베이스

MySQL 스토리지 아키텍처
/var/folders/8_/z9yztddj6wbczy__9s_gjwr00000gn/T/TemporaryItems/NSIRD_screencaptureui_w7rAdU/스크린샷 2023-02-25 오후 11.55.43.png

스토리지 엔진
- 데이터베이스의 심장. 모듈식 아키텍처로 쉽게 스토리지 엔진을 바꿀 수 있음.
- 실제 데이터를 디스크 스토리지에 저장하거나 데이터를 읽어오는 부분을 담당
- 각 스토리지 엔진은 성능 향상을 위해 각각의 다른 형태의 캐시 기능을 내장

## NoSQL 데이터베이스
NoSQL(Not only SQL)
- 구조적 쿼리 언어(SQL)을 사용하지 않는 데이터베이스
- 대표적 데이터베이스 시스템으로는 NoSQL  MongoDB, redis 이 있다.
- `SQL`: 구조적 쿼리 언어. 관계형 데이터베이스에 정보를 저장하고 처리하기 위한 프로그래밍 언어. 

MongoDB
- JSON을 통해 데이터에 접근 가능. Binary JSON 형태로 데이터에 저장.
- 도큐먼트 기반의 데이터베이스
- 확장성이 뛰어나며 빅데이터를 저장할 때 성능이 좋음
- 고가용성과 샤딩, 레플리카 셋 지원
샤딩
- 각 DB 서버에서 데이터를 분할하여 저장하는 방식

레플리카 셋
- 일정 개수의 포드를 유지하는 컨트롤러.
- 정해진 수의 동일한 포드가 항상 실행되도록 관리
- 노드 장애 등의 이유로 포드를 사용할 수 없다면 다른 노드에서 포드를 다시 생성


# 4.5 인덱스
## 4.5.1 인덱스의 필요성
- 데이터를 빠르게 찾을 수 있는 하나의 장치 
- 인덱스를 설정하면 테이블 안에 내가 찾고자 하는 데이터를 빠르게 찾을 수 있다.

## 4.5.2 B트리

 /var/folders/8_/z9yztddj6wbczy__9s_gjwr00000gn/T/TemporaryItems/NSIRD_screencaptureui_ZEEZcg/스크린샷 2023-02-26 오전 12.09.28.png

- 데이터베이스와 파일 시스템에서 사용되는 트리 자료구조
- 이진 트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조
- 방대한 양의 저장된 자료를 검색해야 하는 경우 검색어와 자료 비교는 비효율적임
- 자료를 정렬된 상태로 보관, 삽입, 및 삭제를 대수 시간으로 할 수 있음.

인덱스 최적화 기법
- where 절에서 '자주 조회'하고 '수정 빈도'가 낮으며 '데이터 중복'이 적은 컬럼을 선택하는 것이 좋음
- JOIN 조건으로 자주 사용되는 컬럼을 인텍스로 사용하면 좋음
- 데이터의 양이 많을 수록 인덱스 성능 향상이 커짐

인덱스를 사용하면 좋지 않은 경우
- 한 테이블에 인덱스가 너무 많은 경우 데이터 수정 시 소요 시간이 크다
- 성별과 같은 데이터 중복이 높은 값은 추가 저장 공간이나 데이터 수정에 대한 성능 저하 인덱스를 생성하는 것보다 크기 때문에 의미가 없다. 


## 4.6 조인의 종류


조인
: 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것

/var/folders/8_/z9yztddj6wbczy__9s_gjwr00000gn/T/TemporaryItems/NSIRD_screencaptureui_KY7elT/스크린샷 2023-02-26 오전 12.18.32.png

1) 내부 조인(inner join)
- 왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기
- 두 테이블 간의 교집합을 나타냄
2) 왼쪽 조인(left outer join)
- 테이블 B에 일치하는 부분의 레코드와 함께 테이블 A를 기준으로 완전한 레코드 집합 생성 
- 왼쪽 테이블의 모든 행이 결과 테이블에 표기
3) 오른쪽 조인(right outer join)
- 테이블 A에서 일치하는 부분의 레코드와 함께 테이블 B를 기준으로 완전한 레코드 집합을 생성
- 오른쪽 테이블의 모든 행이 결과 테이블에 표기
4) 합집합 조인(full outer join)
- 양쪽 테이블에서 일치하는 레코드와 함께 테이블 A와 테이블 B의 모든 레코드 집합을 생성
- 일치하는 항목이 없으면 누락된 쪽에 null 값이 포함되어 출력
- 두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기



## 4.7 조인의 원리 
### 4.7.1 중첩 루프 조인(NL Join)
- 반복문의 외부에 있는 테이블을 선행 테이블 또는 외부 테이블(Outer Table)이라고 함
- 반복문 내부에 있는 테이블을 후행 테이블 또는 내부 테이블(Inner Table)이라고 함
- 선행 테이블 조건을 만족하는 행을 추출하여 후행 테이블을 읽으면서 조인을 수행
- 랜덤 방식으로 데이터를 엑세스

### NJ Join의 동작 원리 
1. 선행 테이블에서 주어진 조건을 만족하는 행을 찾음
2. 선행 테이블의 조인 키 값을 가지고 후행 테이블에서 조인 수행
3. 선행 테이블의 조건을 만족하는 모든 행에 대해 1번 작업 반복 수행

### 4.7.2 정렬 병합 조인(Sort Merge Join)
- 각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행하는 조인

### 4.7.3 해시 조인
- 해시 테이블을 기반으로 조인하는 방법
- 조인을 수행할 테이블의 조인 칼럼을 기준으로 해시 함수를 수행하여 서로 동일한 해시 값을 갖는 것들 사이에서 실제 값이 같은지를 비교하면서 조인을 수행
- NL Join의 랜덤 액세스 문제점과 Sort Merge Join의 문제점인 정렬 작업의 부담을 해결

