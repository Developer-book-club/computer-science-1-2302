# 4.1. 데이터베이스의 기본

### 데이터베이스(DB, DataBase)

❓ 일정한 규칙, 규약을 통해 구조화되어 저장되는 데이터의 모음
- 실시간 접근과 동시 공유 가능
- 데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 **쿼리 언어**(query language)를 통해 삽입, 삭제, 수정, 조회 등을 수행할 수 있음

|응용 프로그램(Node.js/php)|
|:---:|
|↕|
|DBMS(MySQL)|
|↕|
|데이터베이스|

## 4.1.1. 엔터티(entity)

❓ 사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사를 의미
> ex) 엔터티: 회원 / 속성: 이름, 아이디, 주소, 전화번호 등...

### 약한 엔터티와 강한 엔터티

- A가 혼자서는 존재하지 못하고 B의 존재 여부에 따라 종속적이라면 A는 약한 엔터티, B는 강한 엔터티
> 방: 약한 엔터티 / 건물: 강한 엔터티   ➡ 방은 건물 안에만 존재하기 때문

## 4.1.2. 릴레이션(relation)

❓ 데이터베이스에서 정보를 구분하여 저장하는 기본 단위
- 엔터티에 관한 데이터를 데이터베이스는 릴레이션 하나에 담아서 관리
> 테이블: 관계형 데이터베이스에서의 릴레이션 <br>
> 컬렉션: NoSQL 데이터베이스에서의 릴레이션

### 테이블과 컬렉션

-데이터베이스의 종류: `관계형 데이터베이스`, `NoSQL`

- **MySQL**(관계형 데이터베이스)의 구조: 레코드-테이블-데이터베이스
- **MongoDB**(NoSQL)의 구조: 도큐먼트-컬렉션-데이터베이스
- 레코드➡테이블➡데이터베이스
![image](https://user-images.githubusercontent.com/70474860/219865490-3946ec50-97f4-46d9-970d-8b0a6a47760c.png)

## 4.1.3. 속성(attribute)

❓ 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보

## 4.1.4. 도메인(domain)

❓ 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합

## 4.1.5. 필드와 레코드

member
|name|ID|address|phonenumber|
|:---:|:---:|:---:|:---:|
|큰돌|kundol|서울|112|
|가영|kay|대전|114|
|빅뱅|big|카이루|119|
|...|...|...|...|

- 회원이란 엔터티는 member라는 테이블로 속성인 이름, 아이디 등을 가지고 있으며 name, ID, address 등의 **필드**를 가짐
- 이 테이블에 쌓이는 행(row) 단위의 데이터를 **레코드** 또는 **튜플**이라고 함

### 필드 타입

- 필드는 타입을 가짐
- 숫자 타입: `TINYINT`, `SMALLINT`, `MEDIUMINT`, `INT`, `BIGINT`
- 날짜 타입: `DATE`, `DATETIME`, `TIMESTAMP`
- 문자 타입: `CHAR`, `VARCHAR`, `TEXT`, BLOB`, `ENUM`, `SET`

## 4.1.6. 관계

- **1:1 관계**: 유저:유저 이메일
- **1:N 관계**: 쇼핑몰의 장바구니(유저:상품)
- **N:M 관계**: 수강신청(학생:강의)
> N:M 관계는 테이블 두 개를 직접적으로 연결해서 구축하지 않고 1:N, 1:M 관계를 갖는 테이블 두 개로 나눠서 설정함

## 4.1.7. 키
`기본키`, `외래키`, `후보키`, `슈퍼키`, `대체키`

![image](https://user-images.githubusercontent.com/70474860/219866253-305c6b57-1987-4d89-9611-e17e856961db.png)

### 기본키(Primary Key:PK)
- 유일성, 최소성 만족하는 키
- 테이블의 데이터 중 **고유**하게 존재하는 속성
- 자연키 또는 인조키 중에 골라 설정

> ✔ **자연키**: 중복된 값들을 제외하며 중복되지 않는 것을 '자연스레' 뽑다가 나오는 키. 언젠가는 변하는 속성을 가짐. <br>
> ✔ **인조키**: 인위적으로 생성한 키. 자연키와는 대조적으로 변하지 않으므로 보통 기본키는 인조키로 설정

### 외래키(Foreign Key:FK)

- 다른 테이블의 기본키를 그대로 참조하는 값으로 개체와의 관계를 식별하는 데 사용
- 중복되어도 괜찮음

### 후보키(candidate key)
- 기본키가 될 수 있는 후보들이며 유일성과 최소성을 동시에 만족하는 키

### 대체키(alternate key)
- 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키들을 말함

### 슈퍼키(super key)
- 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 

# 4.2. ERD와 정규화 과정

❓ **ERD**(Entity Relationship Diagram): 데이터베이스를 구축할 때 가장 기초적인 뼈대 역할을 하며, 릴레이션 간의 관계들을 정의한 것

## 4.2.1. ERD의 중요성
- ERD는 시스템의 요구 사항을 기반으로 작성되며 이 ERD를 기반으로 데이터베이스를 구축
- 디버깅 또는 비즈니스 프로세스 재설계가 필요한 경우에 설계도 역할 담당
- 장점: 관계형 구조로 표현할 수 있는 데이터를 구성하는 데 유용
- 단점: 비정형 데이터를 충분히 표현할 수 없음

> ✔ **비정형 데이터**: 비구조화 데이터를 말하며, 미리 정의된 데이터 모델이 없거나 미리 정의된 방식으로 정리되지 않은 정보

## 4.2.3. 정규화 과정

❓ 릴레이션 간의 잘못된 종속 관계로 인해 데이터베이스 이상 현상이 일어나서 이를 해결하거나, 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리하는 과정

### 정규형 원칙

- 더 좋은 구조
- 자료의 중복성 ⬇
- 독립적인 관계를 별개의 릴레이션으로 표현
- 각각의 릴레이션은 독립적인 표현이 가능

### 제1정규형

❓ 릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자 값(atomic value)만으로 구성되어야 하는 형태
- 릴레이션의 속성 값 중에서 한 개의 기본키에 대해 두 개 이상의 값을 가지는 반복 집합이 있으면 ❌
- 반복 집합 존재 ➡ 제거
![image](https://user-images.githubusercontent.com/70474860/219867019-406827df-ea19-4d63-bf53-9bfe497f6602.png)

### 제2정규형

![image](https://user-images.githubusercontent.com/70474860/219867345-1a507eb1-ae64-49bf-a8b6-40c1be2d32f9.png)

❓ 릴레이션이 제 1정규형이며 부분 함수의 종속성을 제거한 형태
- 부분 함수의 종속성 제거: 기본키가 아닌 모든 속성이 기본키에 **완전 함수 종속**적인 것
- ❗ 주의: 릴레이션을 분해할 때 동등한 릴레이션으로 분해해야 하고, 정보 손실이 발생하지 않는 무손실 분해로 분해되어야 함

> ✔ **완전 함수 종속**(Full Functional Dependency): A와 B가 릴레이션 R의 속성이고 A → B 종속성이 성립할 때, B가 A의 속성 전체에 함수 종속하고 부분 집합 속성에 함수 종속하지 않을 경우

![image](https://user-images.githubusercontent.com/70474860/219867349-8e545e9f-103a-4692-b743-0db9317e4f57.png)

### 제3정규형

❓ 제2정규형이고 기본키가 아닌 모든 속성이 이행적 함수 종속(transitive FD)을 만족하지 않는 상태

> **이행적 함수 종속**: A → B와 B → C가 존재하면 논리적으로 A → C가 성립하는데, 이때 집합 C가 집합 A에 이행적으로 함수 종속이 되었다고 함

### 보이스/코드 정규형(BCNF 정규형)

![image](https://user-images.githubusercontent.com/70474860/219867991-b05a705a-57b0-4b20-9336-01f7e706cb89.png)


❓ 제3정규형이고, 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태

> ✔ **결정자**: 함수 종속 관계에서 특정 종속자(dependent)를 결정짓는 요소, 'X → Y'일 때 X는 결정자, Y는 종속자

![image](https://user-images.githubusercontent.com/70474860/219868000-035ca7c0-0e9f-4d15-b671-8a5c646c6282.png)

# 4.3. 트랜잭션과 무결성

## 4.3.1. 트랜잭션

❓ 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위
- 데이터베이스에 접근하는 방법은 쿼리이므로, 여러 개의 쿼리들을 하나로 묶는 단위를 말함
- 특징: **ACID**(원자성, 일관성, 독립성, 지속성)

### 원자성(atomicity)

❓ 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징
- "**all or nothing**"
- 트랜잭션 단위로 여러 로직들을 묶을 때 외부 API를 호출하는 것이 있으면 안되며, 만약 있다면 롤백이 일어났을 때 어떻게 해야 할 것인지에 대한 해결 방법이 있어야 하고 트랜잭션 전파를 신경 써서 관리 해야 함

#### 커밋과 롤백
- **커밋(commit)**: 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어
    - 트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장되는 것
    - "커밋이 수행되었다." == "하나의 트랜잭션이 성공적으로 수행되었다."
- **롤백(rollback)**: 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일(취소)
- 커밋과 롤백 덕에 데이터의 무결성이 보장됨
- 데이터 변경 전에 변경 사항을 쉽게 확인할 수 있고 해당 작업을 그룹화할 수 있음

#### 트랜잭션 전파

❓ 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것

### 일관성(consistency)

❓ '허용된 방식'으로만 데이터를 변경해야 하는 것
- 데이터베이스에 기록된 모든 데이터는 여러 가지 조건, 규칙에 따라 유효함을 가져야 함

### 격리성(isolation)

❓ 트랜잭션 수행 시 서로 끼어들지 못하는 것
- 복수의 병렬 트랜잭션은 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동되어야 하고, 데이터베이스는 여러 사용자가 같은 데이터에 접근할 수 있어야 함
- 격리성은 여러 개의 격리 수준으로 나뉘어 격리성을 보장

![image](https://user-images.githubusercontent.com/70474860/219868553-a281d711-b02a-4758-8161-dae54394c02f.png)


- 격리 수준: `SERIALIZABLE`, `REPEATABLE_READ`, `READ_COMMITTED`, `READ_UNCOMMITTED`
- 동시성: `SERIALIZABLE` < `REPEATABLE_READ` < `READ_COMMITTED` < `READ_UNCOMMITTED`
- 격리성: `SERIALIZABLE` > `REPEATABLE_READ` > `READ_COMMITTED` > `READ_UNCOMMITTED`

#### 격리 수준에 따라 발생하는 현상

- **팬텀 리드(phantom read)**: 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우
- **반복 가능하지 않은 조회(non-repeatable read)**: 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우
    - 팬텀 리드와 다른 점: 반복 간으하지 않은 조회는 행 값이 달라질 수도 있는데, 팬텀 리드는 다른 행이 선택될 수도 있다는 것을 의미
- **더티 리드(dirty read)**: 반복 가능하지 않은 조회와 유사하며 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 '커밋되지 않은' 행의 데이터를 읽을 수 있을 때 발생

### 지속성(durability)

❓ 성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것
- 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 함
- 데이터베이스는 이를 위해 체크섬, 저널링, 롤백 등의 기능 제공

> ✔ **체크섬**: 중복 검사의 한 형태로, 오류 정정을 통해 송신된 자료의 무결성을 보호하는 단순한 방법
> ✔ **저널링**: 파일 시스템 또는 데이터베이스 시스템에 변경 사항을 반영(commit)하기 전에 로깅하는 것, 트랜잭션 등 변경 사항에 대한 로그를 남기는 것

## 4.3.2. 무결성

❓ 데이터의 정확성, 일관성, 유효성을 유지하는 것
- 무결성이 유지되어야 데이터베이스에 저장된 데이터 값과 그 값에 해당하는 현실 세계의 실제 값이 일치하는지에 대한 신뢰가 생김
- 무결성의 종류

|이름|설명|
|---|---|
|개체 무결성|기본키로 선택된 필드는 빈 값을 허용하지 않는다.|
|참조 무결성|서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야 한다.|
|고유 무결성|특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값을 가진다.|
|NULL 무결성|특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될 수 없다는 제약 조건이다.|

# 4.4. 데이터베이스의 종류

## 4.4.1. 관계형 데이터베이스

❓ 행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스

### MySQL

- 대부분의 운영체제와 호환되며 현재 가장 많이 사용하는 데이터베이스
- C, C++로 만들어짐
- MyISAM 인덱스 압축 기술, B-트리 기반의 인덱스, 스레드 기반의 메모리 할당 시스템, 매우 빠른 조인, 최대 64개의 인덱스를 제공
- 대용량 데이터베이스를 위해 설계되어 있음
- 롤백, 커밋, 이중 암호 지원 보안 등의 기능을 제공
- 모듈식 아키텍처로 쉽게 스토리지 엔진을 바꿀 수 있으며 데이터 웨어하우징, 트랜잭션 처리, 고가용성 처리에 강점
- 쿼리 캐시를 지원해서 입력된 쿼리 문에 대한 전체 결과 집합을 저장하기 때문에 사용자가 작성한 쿼리가 캐시에 있는 쿼리와 동일하면 서버는 단순히 구문 분석, 최적화 및 실행을 건너뛰고 캐시의 출력만 표시     => 8.0부터 없어짐 (cf. https://dev.mysql.com/blog-archive/mysql-8-0-retiring-support-for-the-query-cache/)
- **RDBMS**(순수 관계형 데이터베이스)

### PostgreSQL

- **VACUUM**(디스크 조각이 차지하는 영역을 회수할 수 있는 장치)이 특징
- SQL, JSON을 이용해서 데이터에 접근 가능 (MySQL도 가능)
- 지정 시간에 복구하는 기능, 로깅, 접근 제어, 중첩된 트랜잭션, 백업 등을 할 수 있음
- **ORDBMS**(개체 관계형 데이터베이스): 테이블 상속, 함수 오버로딩 가능

#### MySQL vs. PostgreSQL

|MySQL|PostgreSQL|
|:---:|:---:|
|C, C++|C|
|SQL과 약하게 일치|SQL 표준을 따름
|간단한 데이터 전송을 위해 데이터베이스가 필요한 웹 애플리케이션에 유용|읽기 및 쓰기 데이터베이스 성능이 중요한 복잡한 네트워크에서 유용|

## 4.4.2. NoSQL 데이터베이스

❓ Not only SQL이라는 슬로건에서 생겨난 데이터베이스로, SQL을 사용하지 않는 데이터베이스

### MongoDB

- JSON을 통해 데이터에 접근 가능하고, Binary JSON 형태(BSON)로 데이터가 저장
- 키-값 데이터 모델에서 확장된 도큐먼트 기반의 데이터베이스
- 확장성이 뛰어나며 빅데이터를 저장할 때 성능이 좋고 고가용성과 샤딩, 레플리카셋을 지원
- 스키마를 정해 놓지 않고 데이터를 삽입할 수 있기 때문에 다양한 도메인의 데이터베이스를 기반으로 분석하거나 로깅 등을 구현할 때 강점
- 도큐먼트를 생성할 때마다 다른 컬렉션에서 중복된 값을 지니기 힘든 유니크한 값인 ObjectID가 생성

### redis

- 인메모리 데이터베이스이자 키-값 데이터 모델 기반의 데이터베이스
- 기본적인 데이터 타입은 문자열(string)이며 최대 512MB까지 저장 가능
- 셋(set), 해시(hash) 등을 지원
- pub/sub 기능을 통해 채팅 시스템, 다른 데이터베이스 앞단에 두어 사용하는 캐싱 계층, 단순한 키-값이 필요한 ㅔ션 정보 관리, 정렬된 셋(sorted set) 자료 구조를 이용한 실시간 순위표 서비스에 용이

|MongoDB|redis|
|:---:|:---:|
|SQL DB 같은 dynamic query에 유용|메모리 DB이므로 증권거래 등 예측가능한 규모의 빠른 변경 처리에 적합|

# 4.5. 인덱스

## 4.5.1. 인덱스의 필요성

- **인덱스**: 데이터를 빠르게 찾을 수 있는 하나의 장치

## 4.5.2. B-트리

- 인덱스는 보통 B-트리라는 자료 구조로 이루어져 있음
- 루트 노드, 리프 노드, 브랜치 노드로 나뉨

![image](https://user-images.githubusercontent.com/70474860/219869458-8e197c0e-8ce8-4b22-8407-48b20926b68b.png)

     예를 들어 E를 찾는다고 하면 전체 테이블을 탐색하는 것이 아니라 E가 있을 법한 리프 노드로 들어가서 E를 탐색하면 쉽게 찾을 수 있다.
     이 자료 구조 없이 E를 탐색하고자 하면 A, B, C, D, E 다섯 번을 탐색해야 하지만, 이렇게 노드들로 나누면 두 번만에 리프 노드에서 찾을 수 있다.
<<<<<<< HEAD

## 4.5.4. 인덱스 최적화 기법

### 1. 인덱스는 비용이다

- 두 번 탐색하도록 강요되기 때문에, 관련 읽기 비용이 들게 됨
- 컬렉션이 수정되었을 때 인덱스도 수정되어야 함
- 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적

### 2. 항상 테스팅하라

- 서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 때문에 인덱스 최적화 기법은 서비스 특징에 따라 다름
- `explain()` 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스티을 하며  걸리는 시간을 최소화 해야 함

```SQL
EXPLAIN
SELECT * FROM t1
JOIN t2 ON t1.c1 = t2.c1
```

### 3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다

- 인덱스를 생성할 때는 순서가 있고 생성 순서에 따라 인덱스 선으이 다라짐
- 생성 순서: 같음 ➡ 정렬 ➡ 다중 값 ➡ 카디널리티

>> ✅ **카디널리티**: 유니크한 값의 정도
=======
>>>>>>> upstream/main

# 4.6. 조인의 종류

❓ **조인(join)**: 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것
- MySQL에서의 쿼리 ➡ JOIN
- MongoDB에서의 쿼리 ➡ lookup
- MongoDB는 조인 연산(lookup)에 대해 관계형 데이터베이스보다 성능이 떨어짐
- 여러 테이블을 조인하는 작업이 많을 경우 ➡ 관계형 데이터베이스 사용

![image](https://user-images.githubusercontent.com/70474860/219869771-1470d1f7-22e6-4868-a15d-1a9a1e3b242c.png)


- 조인의 종류: `내부 조인`, `왼쪽 조인`, `오른쪽 조인`, `합집합 조인`
        - **내부 조인(inner join)**: 왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기
        - **왼쪽 조인(left outer join)**: 왼쪽 테이블의 모든 행이 결과 테이블에 표기
        - **오른쪽 조인(right outer join)**: 오른쪽  테이블의 모든 행이 결과 테이블에 표기
        - **합집합 조인(full outer join)**: 두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기

## 4.6.1. 내부 조인

```sql
SELECT * FROM TableA A
INNER JOIN TableB B ON
A.key = B.key
```

## 4.6.2. 왼쪽 조인

```sql
SELECT * FROM TableA A
LEFTR JOIN TableB B ON
A.key = B.key
```

## 4.6.3. 오른쪽 조인

```sql
SELECT * FROM TableA A
RIGHT JOIN TableB B ON
A.key = B.key
```

## 4.6.4. 합집합 조인

```sql
SELECT * FROM TableA A
FULL OUTER JOIN TableB B ON
A.key = B.key
```

# 4.7. 조인의 원리

## 4.7.1. 중첩 루프 조인(Nested Loop Join:NLJ)

- 중첩 for문과 같은 원리로 조건에 맞는 조인을 하는 방법
- 랜덤 접근에 대한 비용이 많이 증가하므로 대용량의 테이블에서는 사용하지 않음
- 블록 중첩 루프 조인(Block Nested Loop:BNL): 중첩 루프 조인에서 발전한 조인할 테이블을 작은 블록으로 나눠서 블록 하나씩 조인하는 방식

## 4.7.2. 정렬 병합 조인

- 각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행
- 조인할 때 쓸 적절한 인덱스가 없고 대용량의 테이블들을 조인하고 조인 조건으로 <, > 등 범위 비교 연산자가 있을 때 사용

## 4.7.3. 해시 조인

- 해시 테이블을 기반으로 조인하는 방법
- 두 개의 테이블을 조인한다고 했을 때 하나의 테이블이 메모리에 온전히 들어간다면 보통 중첩 루프 조인보다 더 효율적
- 메모리에 올릴 수 없을 정도로 크다면 디스크를 사용하는 비용 발생
- 동등(=) 조인에서만 사용 가능
- MySQL의 해시 조인 단계: `빌드 단계`, `프로브 단계`

### 빌드 단계

![image](https://user-images.githubusercontent.com/70474860/219870730-ec28a3f4-c58a-4c19-80b9-c827661f2e66.png)

- 입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계

> ex) <br>
> **빌드**: persons와 countries라는 테이블을 조인한다고 했을 때 둘 중에 바이트가 더 작은 테이블을 기반으로 해서 테이블을 빌드 <br>
> 조인에 사용되는 필드가 해시 테이블의 키로 사용됨 <br>
> `countries.country_id`가 키로 사용됨

### 프로브 단계

![image](https://user-images.githubusercontent.com/70474860/219870774-f0e52898-6fac-418d-865f-967aaef45f18.png)

> ex) <br>
> **프로브**: 레코드 읽기를 시작하며, 각 레코드에서 `persons.country_id`에 일치하는 레코드를 찾아서 결과값으로 반환

- 이를 통해 각 테이블은 한 번씩만 읽게 되어 중ㅈ첩해서 두 개의 테이블을 읽는 중첩 루프 조인보다 보통은 성능이 더 좋음
- 사용 가능한 메모리양 제어는 시스템 변수 join_buffer_size이며, 런타임 시에 조정 가능
