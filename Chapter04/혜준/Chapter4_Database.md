# 4.1. 데이터베이스의 기본

### 데이터베이스(DB, DataBase)

❓ 일정한 규칙, 규약을 통해 구조화되어 저장되는 데이터의 모음
- 실시간 접근과 동시 공유 가능
- 데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 **쿼리 언어**(query language)를 통해 삽입, 삭제, 수정, 조회 등을 수행할 수 있음

|응용 프로그램(Node.js/php)|
|:---:|
|↕|
|DBMS(MySQL)|
|↕|
|데이터베이스|

## 4.1.1. 엔터티(entity)

❓ 사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사를 의미
> ex) 엔터티: 회원 / 속성: 이름, 아이디, 주소, 전화번호 등...

### 약한 엔터티와 강한 엔터티

- A가 혼자서는 존재하지 못하고 B의 존재 여부에 따라 종속적이라면 A는 약한 엔터티, B는 강한 엔터티
> 방: 약한 엔터티 / 건물: 강한 엔터티   ➡ 방은 건물 안에만 존재하기 때문

## 4.1.2. 릴레이션(relation)

❓ 데이터베이스에서 정보를 구분하여 저장하는 기본 단위
- 엔터티에 관한 데이터를 데이터베이스는 릴레이션 하나에 담아서 관리
> 테이블: 관계형 데이터베이스에서의 릴레이션 <br>
> 컬렉션: NoSQL 데이터베이스에서의 릴레이션

### 테이블과 컬렉션

-데이터베이스의 종류: `관계형 데이터베이스`, `NoSQL`
-**MySQL**(관계형 데이터베이스)의 구조: 레코드-테이블-데이터베이스
-**MongoDB**(NoSQL)의 구조: 도큐먼트-컬렉션-데이터베이스
- 레코드➡테이블➡데이터베이스
![image](https://user-images.githubusercontent.com/70474860/219865490-3946ec50-97f4-46d9-970d-8b0a6a47760c.png)

## 4.1.3. 속성(attribute)

❓ 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보

## 4.1.4. 도메인(domain)

❓ 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합

## 4.1.5. 필드와 레코드

member
|name|ID|address|phonenumber|
|:---:|:---:|:---:|:---:|
|큰돌|kundol|서울|112|
|가영|kay|대전|114|
|빅뱅|big|카이루|119|
|...|...|...|...|

- 회원이란 엔터티는 member라는 테이블로 속성인 이름, 아이디 등을 가지고 있으며 name, ID, address 등의 **필드**를 가짐
- 이 테이블에 쌓이는 행(row) 단위의 데이터를 **레코드** 또는 **튜플**이라고 함

### 필드 타입

- 필드는 타입을 가짐
- 숫자 타입: `TINYINT`, `SMALLINT`, `MEDIUMINT`, `INT`, `BIGINT`
- 날짜 타입: `DATE`, `DATETIME`, `TIMESTAMP`
- 문자 타입: `CHAR`, `VARCHAR`, `TEXT`, BLOB`, `ENUM`, `SET`

## 4.1.6. 관계

- **1:1 관계**: 유저:유저 이메일
- **1:N 관계**: 쇼핑몰의 장바구니(유저:상품)
- **N:M 관계**: 수강신청(학생:강의)
> N:M 관계는 테이블 두 개를 직접적으로 연결해서 구축하지 않고 1:N, 1:M 관계를 갖는 테이블 두 개로 나눠서 설정함

## 4.1.7. 키
`기본키`, `외래키`, `후보키`, `슈퍼키`, `대체키`

![image](https://user-images.githubusercontent.com/70474860/219866253-305c6b57-1987-4d89-9611-e17e856961db.png)

### 기본키(Primary Key:PK)
- 유일성, 최소성 만족하는 키
- 테이블의 데이터 중 **고유**하게 존재하는 속성
- 자연키 또는 인조키 중에 골라 설정

> ✔ **자연키**: 중복된 값들을 제외하며 중복되지 않는 것을 '자연스레' 뽑다가 나오는 키. 언젠가는 변하는 속성을 가짐. <br>
> ✔ **인조키**: 인위적으로 생성한 키. 자연키와는 대조적으로 변하지 않으므로 보통 기본키는 인조키로 설정

### 외래키(Foreign Key:FK)

- 다른 테이블의 기본키를 그대로 참조하는 값으로 개체와의 관계를 식별하는 데 사용
- 중복되어도 괜찮음

### 후보키(candidate key)
- 기본키가 될 수 있는 후보들이며 유일성과 최소성을 동시에 만족하는 키

### 대체키(alternate key)
- 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키들을 말함

### 슈퍼키(super key)
- 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 

# 4.2. ERD와 정규화 과정

❓ **ERD**(Entity Relationship Diagram): 데이터베이스를 구축할 때 가장 기초적인 뼈대 역할을 하며, 릴레이션 간의 관계들을 정의한 것

## 4.2.1. ERD의 중요성
- ERD는 시스템의 요구 사항을 기반으로 작성되며 이 ERD를 기반으로 데이터베이스를 구축
- 디버깅 또는 비즈니스 프로세스 재설계가 필요한 경우에 설계도 역할 담당
- 장점: 관계형 구조로 표현할 수 있는 데이터를 구성하는 데 유용
- 단점: 비정형 데이터를 충분히 표현할 수 없음

> ✔ **비정형 데이터**: 비구조화 데이터를 말하며, 미리 정의된 데이터 모델이 없거나 미리 정의된 방식으로 정리되지 않은 정보

## 4.2.3. 정규화 과정

❓ 릴레이션 간의 잘못된 종속 관계로 인해 데이터베이스 이상 현상이 일어나서 이를 해결하거나, 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리하는 과정

### 정규형 원칙

- 더 좋은 구조
- 자료의 중복성 ⬇
- 독립적인 관계를 별개의 릴레이션으로 표현
- 각각의 릴레이션은 독립적인 표현이 가능

### 제1정규형

❓ 릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자 값(atomic value)만으로 구성되어야 하는 형태
- 릴레이션의 속성 값 중에서 한 개의 기본키에 대해 두 개 이상의 값을 가지는 반복 집합이 있으면 ❌
- 반복 집합 존재 ➡ 제거
![image](https://user-images.githubusercontent.com/70474860/219867019-406827df-ea19-4d63-bf53-9bfe497f6602.png)

### 제2정규형

![image](https://user-images.githubusercontent.com/70474860/219867345-1a507eb1-ae64-49bf-a8b6-40c1be2d32f9.png)

❓ 릴레이션이 제 1정규형이며 부분 함수의 종속성을 제거한 형태
- 부분 함수의 종속성 제거: 기본키가 아닌 모든 속성이 기본키에 **완전 함수 종속**적인 것
- ❗ 주의: 릴레이션을 분해할 때 동등한 릴레이션으로 분해해야 하고, 정보 손실이 발생하지 않는 무손실 분해로 분해되어야 함

> ✔ **완전 함수 종속**(Full Functional Dependency): A와 B가 릴레이션 R의 속성이고 A → B 종속성이 성립할 때, B가 A의 속성 전체에 함수 종속하고 부분 집합 속성에 함수 종속하지 않을 경우

![image](https://user-images.githubusercontent.com/70474860/219867349-8e545e9f-103a-4692-b743-0db9317e4f57.png)

### 제3정규형

❓ 제2정규형이고 기본키가 아닌 모든 속성이 이행적 함수 종속(transitive FD)을 만족하지 않는 상태

> **이행적 함수 종속**: A → B와 B → C가 존재하면 논리적으로 A → C가 성립하는데, 이때 집합 C가 집합 A에 이행적으로 함수 종속이 되었다고 함

### 보이스/코드 정규형(BCNF 정규형)

![image](https://user-images.githubusercontent.com/70474860/219867991-b05a705a-57b0-4b20-9336-01f7e706cb89.png)


❓ 제3정규형이고, 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태

> ✔ **결정자**: 함수 종속 관계에서 특정 종속자(dependent)를 결정짓는 요소, 'X → Y'일 때 X는 결정자, Y는 종속자

![image](https://user-images.githubusercontent.com/70474860/219868000-035ca7c0-0e9f-4d15-b671-8a5c646c6282.png)

# 4.3. 트랜잭션과 무결성

## 4.3.1. 트랜잭션

❓ 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위
- 데이터베이스에 접근하는 방법은 쿼리이므로, 여러 개의 쿼리들을 하나로 묶는 단위를 말함
- 특징: **ACID**(원자성, 일관성, 독립성, 지속성)

### 원자성(atomicity)

❓ 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징
- "**all or nothing**"
- 트랜잭션 단위로 여러 로직들을 묶을 때 외부 API를 호출하는 것이 있으면 안되며, 만약 있다면 롤백이 일어났을 때 어떻게 해야 할 것인지에 대한 해결 방법이 있어야 하고 트랜잭션 전파를 신경 써서 관리 해야 함

#### 커밋과 롤백
- **커밋(commit)**: 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어
    - 트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장되는 것
    - "커밋이 수행되었다." == "하나의 트랜잭션이 성공적으로 수행되었다."
- **롤백(rollback)**: 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일(취소)
- 커밋과 롤백 덕에 데이터의 무결성이 보장됨
- 데이터 변경 전에 변경 사항을 쉽게 확인할 수 있고 해당 작업을 그룹화할 수 있음

#### 트랜잭션 전파

❓ 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것

### 일관성(consistency)

❓ '허용된 방식'으로만 데이터를 변경해야 하는 것
- 데이터베이스에 기록된 모든 데이터는 여러 가지 조건, 규칙에 따라 유효함을 가져야 함

### 격리성(isolation)

❓ 트랜잭션 수행 시 서로 끼어들지 못하는 것
- 복수의 병렬 트랜잭션은 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동되어야 하고, 데이터베이스는 여러 사용자가 같은 데이터에 접근할 수 있어야 함
- 격리성은 여러 개의 격리 수준으로 나뉘어 격리성을 보장

![image](https://user-images.githubusercontent.com/70474860/219868553-a281d711-b02a-4758-8161-dae54394c02f.png)


- 격리 수준: `SERIALIZABLE`, `REPEATABLE_READ`, `READ_COMMITTED`, `READ_UNCOMMITTED`
- 동시성: `SERIALIZABLE` < `REPEATABLE_READ` < `READ_COMMITTED` < `READ_UNCOMMITTED`
- 격리성: `SERIALIZABLE` > `REPEATABLE_READ` > `READ_COMMITTED` > `READ_UNCOMMITTED`

#### 격리 수준에 따라 발생하는 현상

- **팬텀 리드(phantom read)**: 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우
- **반복 가능하지 않은 조회(non-repeatable read)**: 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우
    - 팬텀 리드와 다른 점: 반복 간으하지 않은 조회는 행 값이 달라질 수도 있는데, 팬텀 리드는 다른 행이 선택될 수도 있다는 것을 의미
- **더티 리드(dirty read)**: 반복 가능하지 않은 조회와 유사하며 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 '커밋되지 않은' 행의 데이터를 읽을 수 있을 때 발생

### 지속성(durability)

❓ 성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것
- 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 함
- 데이터베이스는 이를 위해 체크섬, 저널링, 롤백 등의 기능 제공

> ✔ **체크섬**: 중복 검사의 한 형태로, 오류 정정을 통해 송신된 자료의 무결성을 보호하는 단순한 방법
> ✔ **저널링**: 파일 시스템 또는 데이터베이스 시스템에 변경 사항을 반영(commit)하기 전에 로깅하는 것, 트랜잭션 등 변경 사항에 대한 로그를 남기는 것

## 4.3.2. 무결성

❓ 데이터의 정확성, 일관성, 유효성을 유지하는 것
- 무결성이 유지되어야 데이터베이스에 저장된 데이터 값과 그 값에 해당하는 현실 세계의 실제 값이 일치하는지에 대한 신뢰가 생김
- 무결성의 종류

|이름|설명|
|---|---|
|개체 무결성|기본키로 선택된 필드는 빈 값을 허용하지 않는다.|
|참조 무결성|서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야 한다.|
|고유 무결성|특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값을 가진다.|
|NULL 무결성|특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될 수 없다는 제약 조건이다.|

# 4.5. 인덱스

## 4.5.1. 인덱스의 필요성

- **인덱스**: 데이터를 빠르게 찾을 수 있는 하나의 장치

## 4.5.2. B-트리

- 인덱스는 보통 B-트리라는 자료 구조로 이루어져 있음
- 루트 노드, 리프 노드, 브랜치 노드로 나뉨

![image](https://user-images.githubusercontent.com/70474860/219869458-8e197c0e-8ce8-4b22-8407-48b20926b68b.png)

        예를 들어 E를 찾는다고 하면 전체 테이블을 탐색하는 것이 아니라 E가 있을 법한 리프 노드로 들어가서 E를 탐색하면 쉽게 찾을 수 있다. 이 자료 구조 없이 E를 탐색하고자 하면 A, B, C, D, E 다섯 번을 탐색해야 하지만, 이렇게 노드들로 나누면 두 번만에 리프 노드에서 찾을 수 있다.

# 4.6. 조인의 종류

❓ **조인(join)**: 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것
- MySQL에서의 쿼리 ➡ JOIN
- MongoDB에서의 쿼리 ➡ lookup
- MongoDB는 조인 연산(lookup)에 대해 관계형 데이터베이스보다 성능이 떨어짐
- 여러 테이블을 조인하는 작업이 많을 경우 ➡ 관계형 데이터베이스 사용

![image](https://user-images.githubusercontent.com/70474860/219869771-1470d1f7-22e6-4868-a15d-1a9a1e3b242c.png)


- 조인의 종류: `내부 조인`, `왼쪽 조인`, `오른쪽 조인`, `합집합 조인`

## 4.6.1.

